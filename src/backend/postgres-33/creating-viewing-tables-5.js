// Postgre 33

// Creating and Viewing Tables

    // overview: A PostgreSQL database is made up of several components, of which the table is most significant. The database table is where all of the data in a database is stored. In this lesson, you'll learn how to define a table, the columns in the table, and each column's data type; this is a fundamental skill that you will need when working with databases.

// terms:

    // data definition language: DDL, a subset of SQL commands used to define the tables in the database

// Structured Query Language (SQL)

    // SQL is the database language used to perform operations on a database. You can use SQL to create a database. SQL uses certain commands, such as CREATE, DROP, and, INSERT, to carry out various tasks.

    // SQL operations can be performed on any object in the database, not just tables.

    // SQL commands fall into four categories:

        // Data Definition Language DDL

        // Data Query Language DQL

        // Data Manipulation Language DML

        // Data Control Language DCL

            // used by database administrators to configure security access to the database; out of scope for this module

// Data Definition Lanuage DDL

    // A subset of SQL commands that is used to define the tables in the database

    // It is used to create and modify any object in the database.

    // Most common DDL commands:

        // CREATE is used to add new tables to the database.

        // ALTER is used to alter the structure of the database.

        // TRUNCATE is used to remove all records from a table, including removing all storage space allocated for the records.

        // DROP is used to delete tables from the database.

    // CREATE TABLE statement

        /*
        CREATE TABLE table_name (
            column_name data_type column_constraint [ , ]
        );
        */

        // Line 49 is called a column definition, and there must be at least one column definition in the table

        // A column definition describes a column in a table.

        // There are many decisions that must be made for each column. In particular, the following decision must be made:

            // What is the name of the column?

            // What is the data type of the data in the column?

            // What is the size of max length of the column?

            // Are null values allowed in the column?

            // Is there a default value?

            // Is the column the primary key or part of the primary key?

        // Tip: Table names in PostgreSQL are lowercase; words are separated by an underscore _ and are plural by default (such as users, products, orders, and order_items).

        // Tip: It's best to declare a NOT NULL constraint on each column for which a null would be nonsensical. Rather than rely on application code, allow the database to enforce constraints uniformly.

        // Fields are filled in with the DEFAULT value when a new row is created and no value is specified for that field. If no default value is declared explicitly, then NULL is the default value.

        // More often than not, however, you need to introduce a column specifically to be a primary key, as in the user_id column for the users table. In such instances, you need to consider how you would make that ID unique for each new row inserted into the table. There are several options available. You can use a library such as uuid to generate a random value. Or you can simply create a serial value that increments the primary key by 1 each time that a new row is inserted. Because an automatically incremented serial value is fairly common and quite easy to do, you will use that option here.

        // Finally, if a column must have a unique value in the table, you can add UNIQUE to constrain the table to only allow unique values in the column. For example, it would be very confusing for two users to have the same user_name value, so you should add the UNIQUE constraint to that column. This means every row in the entire table must have a unique value in the user_name column.

        // For example, the following column definition creates a primary key column that automatically increments for each new row:

        // user_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY

        // So, the following DDL will create the users table:

        /*
        CREATE TABLE users (
            user_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            user_name varchar(50) NOT NULL UNIQUE,
            role varchar DEFAULT 'user'
        );
        */

// DO THIS: Execute The Create-Users-Table Script

    // PostgeSQL, and several other databases, have special syntax to create the table only if it doesn't exist; you do this by adding IF NOT EXISTS.

    // Add IF NOT EXISTS after TABLE on the first line

    // Now, execute the above create-users-table script multiple times. Notice that no matter how many times you execute the script, it is successful.

    // As you observed, this script can be executed multiple times without error and without changing the database beyond the first successful execution. Writing your DDL scripts this way makes it possible to have a single script to automate the creation of the database from any starting point, without encountering the errors that would occur when trying to create tables that already exist.

// Listing Tables

    // At times you will want to get information about existing PostgreSQL tables. PostgreSQL provides an information_schema schema that can return information about all of the objects in the database, including tables.

// DO THIS: Query List Of Tables

    // Execute the following script to see a list of tables in your database:

        /*
        SELECT
            table_name
        FROM
            information_schema.tables
        WHERE
            table_schema = 'public'
            AND table_type = 'BASE TABLE'
        ORDER BY
            table_name;
        */

    // The above SQL is asking the following question: which tables exist in the public schema?

    // Any time that a script starts with SELECT, it is asking a question (which is also called querying)

    // SELECT is part of dta query query language (DQL), a subset of SQL

// Describing A Table

    // At times, you will want to get information about the existing columns in a table. For example, what are the column names? For each column, what is the data type? Is it nullable? Does it have a default value? And so on. This type of query is commonly called a table description.

    // Execute the following script to see a description of the users table:

        /*
        SELECT
            table_name,
            column_name,
            data_type,
            is_nullable,
            column_default,
            is_identity
        FROM
            information_schema.columns
        WHERE
            table_schema = 'public'
            and table_name = 'users';
        */

// ALTER TABLE Statement

    // Sometimes, it's necessary to make changes to a table after it has been created. Especially when the database already contains data, deleting and recreating the table may not be possible.
    
    // The syntax to add a column with the ALTER TABLE statement is as follows:

        // ALTER TABLE <table name> ADD COLUMN IF NOT EXISTS <column definition>;

    // And to remove a column, the syntax is like this:

        // ALTER TABLE <table name> DROP IF EXISTS COLUMN <column name>;

// DO THIS: Add A Birthday Column

    // You now need to add a birthday column to the users table. This will be the date part only, and no time value is needed. Next, there is no default value for birthday that makes sense, so the column won't have a default value. Then, it cannot be null, because every user has a birthday. Finally, the script should only add the birthday column if the column doesn't already exist.

    // ALTER TABLE users ADD COLUMN IF NOT EXISTS birthday date NOT null;

// DO THIS: Make Role Non-nullable

    // Note that the role column will allow null values. Suppose that you don't want the user role to be null because the role will be used to determine which menu options the user will see on the website using this database. As a result, the role column should always have a value

    // We will use the ALTER TABLE statement to set NOT NULL on the role column

    // ALTER TABLE users ALTER COLUMN role SET NOT NULL;

// Suppose that as time goes on, some of your users stop using the application. Rather than delete the user, you would like to set a TRUE-FALSE value indicating whether or not the user is an active user. Next, you will add a boolean column named is_active, which will be TRUE by default.

// DO THIS: Add is_active Column

    // ALTER TABLE users ADD COLUMN IF NOT EXISTS is active boolean NOT NULL default true;

// DROP TABLE Statement

// DO THIS: Drop The users Table

    // delete the users table with the following script

    // DROP TABLE IF EXISTS users;